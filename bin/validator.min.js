const TYPE_CONVERSION_ERROR=Symbol("TYPE_CONVERSION_ERROR");function interpolate(e,r={}){return e?e.replace(/\$\{(\w+)\}/g,((e,t)=>r[t]??"")):""}function getErrorMessage(e,r,t,s){const a=e?.[r],i=e?.default;return interpolate(a?.[t],s)??interpolate(a?.default,s)??interpolate(i?.[t],s)??interpolate(i?.default,s)??`[${r}] validation failed`}function convertByType(e,r){try{switch(r){case"number":const r=parseFloat(e);if(isNaN(r))throw new Error("NaN");return r;case"boolean":if("true"===e||"on"===e)return!0;if("false"===e||"off"===e)return!1;throw new Error("Invalid boolean");case"date":const t=new Date(e);if(isNaN(t.getTime()))throw new Error("Invalid Date");return t;case"string":return null==e?"":String(e);default:return e}}catch(e){return TYPE_CONVERSION_ERROR}}export class Validator{#e;#r;#t;static#s={};constructor(e){this.#e=e,this.#r={},this.#t=[]}validate(e,r="en"){this.#r={},this.#t=[];const t=this.#e.fields||{},s=Validator.#s;for(const[a,i]of Object.entries(t)){const t=convertByType(e[a],i.type||"string"),o=i.messages||{},n={...i,value:t};if(t!==TYPE_CONVERSION_ERROR)for(const[e,l]of Object.entries(i)){if(!(e in s))continue;if(!(0,s[e])(t,l)){const t=getErrorMessage(o,e,r,n);this.#a(a,t)}}else{const e=getErrorMessage(o,"type",r,n);this.#a(a,e)}}for(const t of this.#e.crossFieldValidations||[]){if(!this.#i(t.rule,e)){const s=getErrorMessage(t.message,t.target||"default",r,e),a=t.target||t.fields?.[0];this.#t.push({type:"crossField",fields:t.fields,target:a,message:s}),this.#a(a,s)}}return{valid:0===Object.keys(this.#r).length,errors:this.#r,crossErrors:this.#t}}#a(e,r){this.#r[e]||(this.#r[e]=[]),this.#r[e].push(r)}#i(e,r){try{return new Function(...Object.keys(r),`return ${e};`)(...Object.values(r))}catch(e){return!1}}static registerRule(e,r){this.#s[e]=r}}Validator.registerRule("required",(e=>null!=e&&""!==e)),Validator.registerRule("minLength",((e,r)=>"string"==typeof e&&e.length>=r)),Validator.registerRule("maxLength",((e,r)=>"string"==typeof e&&e.length<=r)),Validator.registerRule("min",((e,r)=>e instanceof Date&&!isNaN(e)?e>=new Date(r):"number"==typeof e&&e>=r)),Validator.registerRule("max",((e,r)=>e instanceof Date&&!isNaN(e)?e<=new Date(r):"number"==typeof e&&e<=r)),Validator.registerRule("pattern",((e,r)=>new RegExp(r).test(e))),Validator.registerRule("format",((e,r)=>{if("string"!=typeof e)return!1;const t={"YYYY/MM/DD":/^\d{4}\/\d{2}\/\d{2}$/,"YYYY-MM-DD":/^\d{4}-\d{2}-\d{2}$/,YYYYMMDD:/^\d{8}$/,YYYYMMDDHHmmss:/^\d{14}$/,ISO8601:/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d+)?(Z|[\+\-]\d{2}:\d{2})?$/,UNIX_MS:/^\d{10,13}$/,TIMESTAMP_MS:/^\d{10,13}$/,"HH:mm:ss":/^\d{2}:\d{2}:\d{2}$/,HHmmss:/^\d{6}$/}[r];return!!t&&t.test(e)})),Validator.registerRule("enum",((e,r)=>Array.isArray(r)&&r.includes(e)));export class SchemaRegistry{#o=new Map;register(e,r){this.#o.set(e,r)}createValidator(e){const r=this.#o.get(e);if(!r)throw new Error(`Schema not found: ${e}`);return new Validator(r)}getSchema(e){return this.#o.get(e)}has(e){return this.#o.has(e)}unregister(e){this.#o.delete(e)}get keys(){return[...this.#o.keys()]}}