const TYPE_CONVERSION_ERROR=Symbol("TYPE_CONVERSION_ERROR");function interpolate(e,r={}){return e?e.replace(/\$\{(\w+)\}/g,((e,t)=>r[t]??"")):""}function getErrorMessage(e,r,t,s){const i=e?.[r],a=e?.default;return interpolate(i?.[t],s)??interpolate(i?.default,s)??interpolate(a?.[t],s)??interpolate(a?.default,s)??`[${r}] validation failed`}function convertByType(e,r){try{switch(r){case"number":const r=parseFloat(e);if(isNaN(r))throw new Error("NaN");return r;case"boolean":if("true"===e||"on"===e)return!0;if("false"===e||"off"===e)return!1;throw new Error("Invalid boolean");case"date":const t=new Date(e);if(isNaN(t.getTime()))throw new Error("Invalid Date");return t;case"string":default:return e}}catch(e){return TYPE_CONVERSION_ERROR}}export class ValidatorEngine{#e;#r;#t;#s;static#i={};constructor(e,r="ja"){this.#e=e,this.#r=r,this.#t={},this.#s=[]}validate(e){this.#t={},this.#s=[];const r=this.#e.fields||{},t=ValidatorEngine.#i;for(const[s,i]of Object.entries(r)){const r=convertByType(e[s],i.type||"string"),a=i.messages||{},n={...i,value:r};if(r!==TYPE_CONVERSION_ERROR)for(const[e,o]of Object.entries(i)){if(!(e in t))continue;if(!(0,t[e])(r,o)){const r=getErrorMessage(a,e,this.#r,n);this.#a(s,r)}}else{const e=getErrorMessage(a,"type",this.#r,n);this.#a(s,e)}}for(const r of this.#e.crossFieldValidations||[]){if(!this.#n(r.rule,e)){const t=getErrorMessage(r.message,r.target||"default",this.#r,e),s=r.target||r.fields?.[0];this.#s.push({type:"crossField",fields:r.fields,target:s,message:t}),this.#a(s,t)}}return{valid:0===Object.keys(this.#t).length,errors:this.#t,crossErrors:this.#s}}#a(e,r){this.#t[e]||(this.#t[e]=[]),this.#t[e].push(r)}#n(e,r){try{return new Function(...Object.keys(r),`return ${e};`)(...Object.values(r))}catch(e){return!1}}static registerRule(e,r){this.#i[e]=r}}ValidatorEngine.registerRule("required",(e=>null!=e&&""!==e)),ValidatorEngine.registerRule("minLength",((e,r)=>"string"==typeof e&&e.length>=r)),ValidatorEngine.registerRule("maxLength",((e,r)=>"string"==typeof e&&e.length<=r)),ValidatorEngine.registerRule("min",((e,r)=>e instanceof Date&&!isNaN(e)?e>=new Date(r):"number"==typeof e&&e>=r)),ValidatorEngine.registerRule("max",((e,r)=>e instanceof Date&&!isNaN(e)?e<=new Date(r):"number"==typeof e&&e<=r)),ValidatorEngine.registerRule("pattern",((e,r)=>new RegExp(r).test(e))),ValidatorEngine.registerRule("format",((e,r)=>"string"==typeof e&&/^\d{4}\/\d{2}\/\d{2}$/.test(e))),ValidatorEngine.registerRule("enum",((e,r)=>Array.isArray(r)&&r.includes(e)));